## 이벤트 제어하기 -> `Debounce` 와 `Throttle`

### 🐱‍🐉 이벤트 제어가 필요한 경우?

짧은 시간 내에 수많은 이벤트가 발생하지만, 발생하는 모든 이벤트에 대한 처리가 필요하진 않은 경우에 이벤트 제어 방식을 적용함으로써 처리량을 조절할 수 있다.

예를 들어, 마우스 움직임이나 타이핑, 또는 스크롤링 등에 의해 발생하는 이벤트

이러한 상황에서 발생하는 모든 이벤트를 처리하려고 하면, 실제 사용자가 채감도 하지 못할 양의 이벤트 처리를 위해 다음과 같은 문제점이 나타날 수 있다.

1. 서버/클라이언트의 리소스 낭비
2. 서비스 성능 저하
3. 사용자 경험 저하

반대로 이벤트 제어를 통해 처리량을 조절하게 되면 다음과 같은 효과를 기대할 수 있다.

1. 서버/클라이언트의 리소스 절약
2. 비용 절감
3. 사용자 경험 개선


### 🐱‍🐉 이벤트 제어 방식

1. `Debounce`

연속적으로 발생하는 이벤트들을 그룹화하여, 해당 이벤트 그룹이 일시정지가 되었다고 판단되는 시점이 지나면 최초 또는 최후의 이벤트에 대해서만 처리하는 방식이다.
즉, 여러번 발생하는 이벤트에서, 가장 마지막 이벤트 만을 실행되도록 만드는 개념


2. `Throttle`

이벤트를 일정 주기마다 처리함으로써 이벤트를 제어한다. 단순히 사용자의 움직임이 멈추었을 때만 동작하는 것이 아니라, 마지막 함수가 호출된 후 일정 시간 이내에 재호출되지 않음으로써, 
처리량은 조절되면서 사용자가 서비스의 연속성도 느낄 수 있다.
즉, 여러번 발생하는 이벤트를 일정 시간 동안, 한번만 실행 되도록 만드는 개념

### 🐱‍🐉 `Debounce`와 `Throttle`의 차이점

`Debounce`와 `Throttle`의 차이점은 이벤트를 언제 발생 시킬지의 시점 차이이다. 
Debounce는 입력이 끝날때까지 무한적으로 기다리지만, Throttle은 입력이 시작되면, 일정 주기로 계속 실행한다.

### 🐱‍🐉 `Debounce` 사용법
```jsx
import React, {useState} from 'react';

const Input = () => {
    
    const [value, setValue] = useState('');
    
    const handleOnchange = (e) => {
        updateList(e.target.value);

        setValue(e.target.value);
    }

    const updateList = () => {
        // findList 하는 내용
    }

    return (
        <input value={value} onChange={handleOnchange} />
    )
}
```
